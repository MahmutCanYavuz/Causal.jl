var documenterSearchIndex = {"docs":
[{"location":"manual/components/sources/generators/#Generators-1","page":"Generators","title":"Generators","text":"","category":"section"},{"location":"manual/components/sources/generators/#FunctionGenerator-1","page":"Generators","title":"FunctionGenerator","text":"","category":"section"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"`FunctionGenerator is the generic function generator. The output waveform is shaped by its output function. A FunctionGenerator can be construted by specifying its output function outputfunc.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"FunctionGenerator","category":"page"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.FunctionGenerator","page":"Generators","title":"Jusdl.Components.Sources.FunctionGenerator","text":"FunctionGenerator(outputfunc)\n\nConstructs a FunctionGenerator with the output of the form x(t) = f(t) where f is outputfunc.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Basic-Operation-AbstractSource-1","page":"Generators","title":"Basic Operation AbstractSource","text":"","category":"section"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"AnAbstractSource is a subtype of AbstractComponent. (See Components for more information.) An AbstractComponent has input and output for data flow. The AbstractComponent reads data from input and writes data to output. Since the input-output relation of AbstractSource depends on just the current time t, Sources does not have inputs since they do not read input values. They just need time t to compute its output. During their evolution, the AbstractComponent read time t from their trigger links, computes their output according to their output function and writes its computed output to their output busses. An AbstractComponent also writes true to their handshake links in signal that the evolution is succeeded. To further clarify the operation of AbstractSource, let us do some examples. ","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"using Jusdl # hide \noutputfunc(t) = t * exp(t) + sin(t)\ngen = FunctionGenerator(outputfunc)","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"We constructed a FunctionGenerator which is an AbstractSource.","category":"page"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"gen isa AbstractSource","category":"page"},{"location":"manual/components/sources/generators/#Full-API-1","page":"Generators","title":"Full API","text":"","category":"section"},{"location":"manual/components/sources/generators/#","page":"Generators","title":"Generators","text":"SinewaveGenerator\nDampedSinewaveGenerator\nSquarewaveGenerator\nTriangularwaveGenerator\nConstantGenerator\nRampGenerator\nStepGenerator\nExponentialGenerator\nDampedExponentialGenerator","category":"page"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.SinewaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.SinewaveGenerator","text":"SinewaveGenerator(;amplitude=1., frequency=1., phase=0., delay=0., offset=0.)\n\nConstructs a SinewaveGenerator with output of the form\n\n    x(t) = A sin(2 pi f  (t - tau) + phi) + B\n\nwhere A is amplitude, f is frequency, tau is delay and phi is phase and B is offset.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.DampedSinewaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.DampedSinewaveGenerator","text":"DampedSinewaveGenerator(;amplitude=1., decay=-0.5, frequency=1., phase=0., delay=0., offset=0.)\n\nConstructs a DampedSinewaveGenerator which generates outputs of the form \n\n    x(t) = A e^alpha t * sin(2 pi f (t - tau) + phi) + B\n\nwhere A is amplitude, alpha is decay, f is frequency, phi is phase, tau is delay and B is offset.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.SquarewaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.SquarewaveGenerator","text":"SquarewaveGenerator(;level1=1., level2=0., period=1., duty=0.5, delay=0.)\n\nConstructs a SquarewaveGenerator with output of the form \n\n    x(t) = leftbeginarraylr\n\tA_1 + B   kT + tau leq t leq (k + alpha) T + tau \n\tA_2 + B    (k + alpha) T + tau leq t leq (k + 1) T + tau\t\n\tendarray right quad k in Z\n\nwhere A_1, A_2 is level1 and level2, T is period, tau is delay alpha is duty. \n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.TriangularwaveGenerator","page":"Generators","title":"Jusdl.Components.Sources.TriangularwaveGenerator","text":"TriangularwaveGenerator(;amplitude=1, period=1, duty=0.5, delay=0, offset=0)\n\nConstructs a TriangularwaveGenerator with output of the form\n\n    x(t) = leftbeginarraylr\n\tdfracA talpha T + B   kT + tau leq t leq (k + alpha) T + tau \n\tdfracA (T - t)T (1 - alpha) + B    (k + alpha) T + tau leq t leq (k + 1) T + tau\t\n\tendarray right quad k in Z\n\nwhere A is amplitude, T is period, tau is delay alpha is duty. \n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.ConstantGenerator","page":"Generators","title":"Jusdl.Components.Sources.ConstantGenerator","text":"ConstantGenerator(;amplitude=1.)\n\nConstructs a Constructs with output of the form\n\n    x(t) = A\n\nwhere A is `amplitude.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.RampGenerator","page":"Generators","title":"Jusdl.Components.Sources.RampGenerator","text":"RampGenerator(;scale=1)\n\nConstructs a RampGenerator with output of the form\n\n    x(t) = alpha t\n\nwhere alpha is the scale.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.StepGenerator","page":"Generators","title":"Jusdl.Components.Sources.StepGenerator","text":"StepGenerator(;amplitude=1, delay=0, offset=0)\n\nConstructs a StepGenerator with output of the form \n\n    x(t) = leftbeginarraylr\n\tB   t leq 0  \n\tA + B    t  0\n\tendarray right\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.ExponentialGenerator","page":"Generators","title":"Jusdl.Components.Sources.ExponentialGenerator","text":"ExponentialGenerator(;scale=1, decay=-1)\n\nConstructs an ExponentialGenerator with output of the form\n\n    x(t) = A e^alpha t\n\nwhere A is scale, alpha is decay.\n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/generators/#Jusdl.Components.Sources.DampedExponentialGenerator","page":"Generators","title":"Jusdl.Components.Sources.DampedExponentialGenerator","text":"DampedExponentialGenerator(;scale=1, decay=-1)\n\nConstructs an DampedExponentialGenerator with outpsuts of the form \n\n    x(t) = A t e^alpha t\n\nwhere A is scale, alpha is decay.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#Links-1","page":"Links","title":"Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Links are built on top of  Channels of Julia. They are used as communication primitives for Tasks of Julia. A Link basically includes a Channel and a Buffer. The mode of the buffer is Cyclic.(see Buffer Modes for information on buffer modes). Every item sent through a Link is sent through the channel of the Link and written to the Buffer so that all the data flowing through a Link is recorded. The data transmitted through a Link can be of any Julia type, even if user-defined types. ","category":"page"},{"location":"manual/connections/link/#Construction-of-Links-1","page":"Links","title":"Construction of Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The construction of a Link is very simple: just specify its buffer length and element type.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Link","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.Link","page":"Links","title":"Jusdl.Connections.Link","text":"Link{T}([ln::Int=64]) where T\n\nConstructs a Link with element type T and buffer length ln. The buffer element type of T and mode is Cyclic.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Here, are some examples.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide \nl1 = Link{Int}(5)\nl2 = Link{Matrix{Float64}}(10)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Similar to the case of Buffers, the data type that can flow the Link can be any Julia type, even a user-defined type. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nstruct Object\n    x::Int \nend \nl = Link{Object}(3)     # A `Link` that with element type `Object` with buffer size `3`.","category":"page"},{"location":"manual/connections/link/#Connection-and-Disconnection-of-Links-1","page":"Links","title":"Connection and Disconnection of Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Links can be connected to each other so that data can flow from one link to another. The flows from link l1 to l2, then l1 is said to drive l2 and l1 is called as master and l2 is called as slave. A Link can have more than one slave but can have just one master. When a Links is initialized, it has no master and slaves.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"connect ","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.connect","page":"Links","title":"Jusdl.Connections.connect","text":"connect(master::Link, slave::Link)\n\nConnects master to slave. When connected, the flow is from master to slave.\n\nconnect(links...)\n\nConnect each link of links in the form of a path.\n\nExample\n\njulia> l1, l2 = Link(), Link();\n\njulia> isconnected(l1, l2)\nfalse\n\njulia> connect(l1, l2)\n\njulia> isconnected(l1, l2)\ntrue\n\njulia> ls = [Link() for i = 1 : 3];\n\njulia> map(i -> isconnected(ls[i], ls[i + 1]), 1 : 2)\n2-element Array{Bool,1}:\n 0\n 0\n\njulia> connect(ls...)\n\njulia> map(i -> isconnected(ls[i], ls[i + 1]), 1 : 2)\n2-element Array{Bool,1}:\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Similarly Links can be disconnected. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"disconnect","category":"page"},{"location":"manual/connections/link/#Jusdl.Connections.disconnect","page":"Links","title":"Jusdl.Connections.disconnect","text":"disconnect(link1::Link, link2::Link)\n\nDisconnects link1 and link2. The order of arguments is not important. \n\nExample\n\njulia> ls = [Link() for i = 1 : 2];\n\njulia> connect(ls[1], ls[2])\n\njulia> disconnect(ls[1], ls[2])\n\njulia> isconnected(ls[1], ls[2])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"warning: Warning\nNote that the order or arguments is important when the links are connected. connect(l1, l2) connects l1 and l2 such that l1 drives l2, i.e., data flows from l1 to l2. In other words, l1 is the master link and l2 is the slave link. However, the order of arguments is not important when the links are disconnected. disconnect(l1, l2) does the same thing with disconnect(l2, l1), i.e., it justs breaks the connection between l2 and l1.","category":"page"},{"location":"manual/connections/link/#Data-Flow-through-Links-1","page":"Links","title":"Data Flow through Links","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The data can be read from and written into Links if active tasks are bound to them. Links can be thought of a pipe. In order to write data to a Link from one of its ends, a task that reads written data from the other end must be bounded to the Link. Similarly, in order to read data from one of the Link from one of its end, a task that writes the read data must be bound to the Link. Reading from and writing to Link is carried out with take! and put! functions. For more clarity, let us see some example. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Let us first construct a Link,","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nl = Link{Float64}(5)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l is a Link with a buffer length of 5 and element type of Float64. Not that the l is open, but it is not ready for data reading or writing. To write data, we must bound a task that reads the written data.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"function reader(link::Link)  # Define job.\n    while true\n        val = take!(link)\n        val === missing && break  # Poison-pill the tasks to terminate safely.\n    end\nend\nt = @async reader(l)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The reader is defined such that the data written from one end of l is read until the data is missing. Now, we have runnable task t. This means the l is ready for data writing. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"put!(l, 1.)\nput!(l, 2.)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"To terminate the task, we must write missing to l.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"put!(l, missing)  # Terminate the task \nt   # Show that the `t` is terminated.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Note that the data flown through the l is written to its buffer. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l.buffer.data","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"When ever the bound task to the l is runnable, the data can be written to l. That is, the data length that can be written to l is not limited by the buffer length of l. But, beware that the buffer of Linkss are Cyclic. That means, when the buffer is full, its data is overwritten.","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"l = Link(5)\nt = @async reader(l)\nfor item in 1. : 10.\n    put!(l, item)\n    @show l.buffer.data\nend","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"The case is very similar to read data from l. Again a runnable task is bound the l ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"using Jusdl # hide\nl = Link(5)\nfunction writer(link::Link, vals)\n    for val in vals\n        put!(link, val)\n    end\nend\nt = @async writer(l, 1.:5.)\nbind(l, t)\ntake!(l)\ntake!(l)","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"It is possible to read data from l until t is active. To read all the data at once, collect can be used. ","category":"page"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"t   \ncollect(l)\nt  # Show that `t` is terminated.","category":"page"},{"location":"manual/connections/link/#Full-API-1","page":"Links","title":"Full API","text":"","category":"section"},{"location":"manual/connections/link/#","page":"Links","title":"Links","text":"Connections.put!(link::Link, val)\nConnections.take!(link::Link)\nConnections.close(link::Link)\nConnections.isopen(link::Link)\nConnections.isreadable(link::Link)\nConnections.iswritable(link::Link)\nConnections.isfull(link::Link)\nConnections.isconnected\nConnections.hasslaves(link::Link) \nConnections.hasmaster(link::Link)\nConnections.getmaster(link::Link) \nConnections.getslaves(link::Link)\nConnections.snapshot(link::Link) \nConnections.Connections.UnconnectedLinkError\nConnections.Connections.Pin\nConnections.findflow(link1::Link, link2::Link) \nConnections.insert\nConnections.release\nConnections.bind\nConnections.collect(link::Link)\nConnections.launch(link::Link) \nConnections.launch(link::Link, valrange) ","category":"page"},{"location":"manual/connections/link/#Base.put!-Tuple{Link,Any}","page":"Links","title":"Base.put!","text":"put!(link::Link, val)\n\nPuts val to link. val is handed over to the channel of link. val is also written in to the buffer of link.\n\nwarning: Warning\nlink must be writable to put val. See launch\n\nExample\n\njulia> l = Link();\n\njulia> t = launch(l);  # To be able to put values, `l` must be bound to a runnable task.\n\njulia> put!(l, 1.)\n┌ Info: Took \n└   val = 1.0\n1.0\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.take!-Tuple{Link}","page":"Links","title":"Base.take!","text":"take!(link::Link)\n\nTake an element from link.\n\nwarning: Warning\nlink must be readable to take value. See launch\n\nExample\n\njulia> l = Link(5);\n\njulia> t = launch(l, 1. : 5.);\n\njulia> for i in 1 : 5\n       @show take!(l)\n       end\ntake!(l) = 1.0\ntake!(l) = 2.0\ntake!(l) = 3.0\ntake!(l) = 4.0\ntake!(l) = 5.0\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.close-Tuple{Link}","page":"Links","title":"Base.close","text":"close(link)\n\nCloses link. All the task bound the link is also terminated safely. When closed, data cannot ben into or read from the link.\n\nExample\n\njulia> l  = Link();\n\njulia> t = launch(l);\n\njulia> put!(l, 1.)\n┌ Info: Took \n└   val = 1.0\n1.0\n\njulia> close(l)\n\njulia> put!(l, 1.)\nERROR: InvalidStateException(\"Channel is closed.\", :closed)\nStacktrace:\n [1] check_channel_state at ./channels.jl:167 [inlined]\n [2] put! at ./channels.jl:323 [inlined]\n [3] put!(::Link{Union{Missing, Float64}}, ::Float64) at /home/sari/.julia/dev/Jusdl/src/connections/link.jl:64\n [4] top-level scope at REPL[99]:1\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.isopen-Tuple{Link}","page":"Links","title":"Base.isopen","text":"open(link::Link)\n\nReturns true if link is open. A link is open if its channel is open.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.isreadable-Tuple{Link}","page":"Links","title":"Base.isreadable","text":"isreadable(link::Link)\n\nReturns true if link is readable. When link is readable, data can be read from link with take function.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Base.iswritable-Tuple{Link}","page":"Links","title":"Base.iswritable","text":"writable(link::Link)\n\nReturns true if link is writable. When link is writable, data can be written into link with put function.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.isfull-Tuple{Link}","page":"Links","title":"Jusdl.Connections.isfull","text":"isfull(link::Link)\n\nReturns true if the buffer of link is full.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.isconnected","page":"Links","title":"Jusdl.Connections.isconnected","text":"isconnected(link1, link2)\n\nReturns true if link1 is connected to link2. The order of the arguments are not important.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.hasslaves-Tuple{Link}","page":"Links","title":"Jusdl.Connections.hasslaves","text":"hasslaves(link::Link)\n\nReturns true if link has slave links.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.hasmaster-Tuple{Link}","page":"Links","title":"Jusdl.Connections.hasmaster","text":"hasmaster(link::Link)\n\nReturns true if link has a master link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.getmaster-Tuple{Link}","page":"Links","title":"Jusdl.Connections.getmaster","text":"getmaster(link::Link)\n\nReturns the master of link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.getslaves-Tuple{Link}","page":"Links","title":"Jusdl.Connections.getslaves","text":"getslaves(link::Link)\n\nReturns the slaves of link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.snapshot-Tuple{Link}","page":"Links","title":"Jusdl.Connections.snapshot","text":"snapshot(link::Link)\n\nReturns all the data of the buffer of link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.UnconnectedLinkError","page":"Links","title":"Jusdl.Connections.UnconnectedLinkError","text":"UnconnectedLinkError <: Exception\n\nException thrown when the links are not connected to each other.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#Jusdl.Connections.Pin","page":"Links","title":"Jusdl.Connections.Pin","text":"Pin()\n\nConstructs a Pin. A Pin is the auxilary type to monitor connection status of Links. See Link\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/link/#Jusdl.Connections.findflow-Tuple{Link,Link}","page":"Links","title":"Jusdl.Connections.findflow","text":"findflow(link1::Link, link2::Link)\n\nReturns a tuple of (masterlink, slavelink) where masterlink is the link that drives the other and slavelink is the link that is driven by the other.\n\nExample\n\njulia> ls = [Link() for i = 1 : 2];\n\njulia> connect(ls[1], ls[2])\n\njulia> findflow(ls[2], ls[1]) .== (ls[1], ls[2])\n(true, true)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.insert","page":"Links","title":"Jusdl.Connections.insert","text":"insert(master::Link, slave::Link, new::Link)\n\nInserts the new link between the master link and slave link. The master is connected to new, and new is connected to slave.\n\nExample\n\njulia> ls = [Link() for i = 1 : 3];  \n\njulia> connect(ls[1], ls[2]) \n\njulia> insert(ls[1], ls[2], ls[3])\n\njulia> isconnected(ls[1], ls[2])\nfalse\n\njulia> isconnected(ls[1], ls[3]) && isconnected(ls[3], ls[2])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Jusdl.Connections.release","page":"Links","title":"Jusdl.Connections.release","text":"release(link::Link)\n\nRelease all the slave links of link. That is, all the slave links of link is disconnected.\n\nExample\n\njulia> ls = [Link() for i = 1 : 5];\n\njulia> foreach(l -> connect(ls[1], l), ls[2:5])\n\njulia> map(l -> isconnected(ls[1], l), ls[2:5])\n4-element Array{Bool,1}:\n 1\n 1\n 1\n 1\n\njulia> release(ls[1])  # Release all the slaves.\n\njulia> map(l -> isconnected(ls[1], l), ls[2:5])\n4-element Array{Bool,1}:\n 0\n 0\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.bind","page":"Links","title":"Base.bind","text":"bind(link::Link, task::Task)\n\nBinds task to link. When task is done link is closed.\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/link/#Base.collect-Tuple{Link}","page":"Links","title":"Base.collect","text":"collect(link::Link)\n\nCollects all the available data on the link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.launch-Tuple{Link}","page":"Links","title":"Jusdl.Connections.launch","text":"launch(link::Link)\n\nConstructs a taker task and binds it to link. The taker task reads the data and prints an info message until missing is read from the link.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/link/#Jusdl.Connections.launch-Tuple{Link,Any}","page":"Links","title":"Jusdl.Connections.launch","text":"launch(link:Link, valrange)\n\nConstructs a putter task and binds it to link. putter tasks puts the data in valrange.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/callback/#Callback-1","page":"Callback","title":"Callback","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Callbacks are used to monitor the existence of a specific events and if that specific event occurs, some other special jobs are invoked. Callbacks are intended to provide additional monitoring capability to any user-defined composite types. As such, Callbacks are generaly fields of user defined composite types objects. When a Callback is called, if the Callback is enabled and its condition function returns true, then its action function is invoked. ","category":"page"},{"location":"manual/utilities/callback/#A-Simple-Example-1","page":"Callback","title":"A Simple Example","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Let's define a test object first that has a field named x of type Int and named callback of type Callback. ","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> mutable struct TestObject\n       x::Int\n       callback::Callback\n       end","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"To construct an instance of TestObject, we need to construct a Callback. For that purpose, condition and action function must be defined. For this example, condition checks whether the x field is positive, and action prints a simple message saying that the x field is positive.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> condition(testobject) = testobject.x > 0 \ncondition (generic function with 1 method)\n\njulia> action(testobject) = println(\"testobject.x is greater than zero\") \naction (generic function with 1 method)","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now a test object can be constructed","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject = TestObject(-1, Callback(condition, action))  \nTestObject(-1, Callback{typeof(condition),typeof(action)}(condition, action, true, \"dac6f9eb-6daa-4622-a8fa-623f0f88780c\"))","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"If the callback is called, no action is performed since the condition function returns false. Note the argument sent to the callback. The instance of the TestObject to which the callback is a bound.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) ","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now mutate the test object so that condition returns true.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.x = 3   \n3","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Now, if the callback is called, since the condition returns true and the callback is enabled, the action is invoked.","category":"page"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) \ntestobject.x is greater than zero","category":"page"},{"location":"manual/utilities/callback/#Full-API-1","page":"Callback","title":"Full API","text":"","category":"section"},{"location":"manual/utilities/callback/#","page":"Callback","title":"Callback","text":"Callback\nenable!\ndisable!\nisenabled\naddcallback\ndeletecallback","category":"page"},{"location":"manual/utilities/callback/#Jusdl.Utilities.Callback","page":"Callback","title":"Jusdl.Utilities.Callback","text":"Callback(condition, action)\n\nConstructs a Callback from condition and action. The condition and action must be a single-argument functions. condition returns true if the condition it checks occurs, otherwise ite returns false. action is performs the specific action for which the Callback the callback is contructed. A Callback can be called by passing its single argument which is mostly bound to the Callback.\n\nExample\n\njulia> struct Object  # Define a dummy type.\n       x::Int \n       clb::Callback \n       end \n\njulia> cond(obj) = obj.x > 0  # Define callback condition.\ncond (generic function with 1 method)\n\njulia> action(obj) = println(\"Printing the object \", obj) # Define callback action.\naction (generic function with 1 method)\n\njulia> obj = Object(1, Callback(cond, action))  # Construct an `Object` instance with `Callback`.\nObject(1, Callback(condition:cond, action:action))\n\njulia> obj.clb(obj)  # Call the callback bound `obj`.\nPrinting the object Object(1, Callback(condition:cond, action:action))\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/callback/#Jusdl.Utilities.enable!","page":"Callback","title":"Jusdl.Utilities.enable!","text":"enable!(clb::Callback)\n\nEnables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.disable!","page":"Callback","title":"Jusdl.Utilities.disable!","text":"disable!(clb::Callback)\n\nDisables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.isenabled","page":"Callback","title":"Jusdl.Utilities.isenabled","text":"isenabled(clb::Callback)\n\nReturns true if clb is enabled. Otherwise, returns false.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.addcallback","page":"Callback","title":"Jusdl.Utilities.addcallback","text":"addcallback(obj, clb::Callback, priority::Int)\n\nAdds clb to callback vector of obj which is assumed the have a callback list which is a vector of callback.\n\nExample\n\njulia> mutable struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       Object(x::Int) = new(x, Callback[])\n       end \n\njulia> obj = Object(5)\nObject(5, Callback[])\n\njulia> condition(val) = val.x == 5\ncondition (generic function with 1 method)\n\njulia> action(val) = @show val.x \naction (generic function with 1 method)\n\njulia> addcallback(obj, Callback(condition, action))\nObject(5, Callback[Callback(condition:condition, action:action)])\n\njulia> obj.callbacks(obj)\nval.x = 5\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/callback/#Jusdl.Utilities.deletecallback","page":"Callback","title":"Jusdl.Utilities.deletecallback","text":"deletecallback(obj, idx::Int)\n\nDeletes the one of the callbacks of obj at index idx.\n\njulia> struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       end\n\njulia> clb1 = Callback(val -> true, val -> nothing);\n\njulia> clb2 = Callback(val -> false, val -> nothing);\n\njulia> obj = Object(5, [clb1, clb2]);\n\njulia> deletecallback(obj, 2);\n\njulia> length(obj.callbacks) == 1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Buffer-1","page":"Buffer","title":"Buffer","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"DocTestSetup  = quote\n    using Jusdl\n    import Utilities: BufferMode, LinearMode, CyclicMode\nend","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer is a primitive to buffer the data. Data can be of any Julia type. Data can be read from and written into a buffer, and the mode of the buffer determines the way to read from and write into the buffers. ","category":"page"},{"location":"manual/utilities/buffers/#Buffer-Modes-1","page":"Buffer","title":"Buffer Modes","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer mode determines the way the data is read from and written into a Buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Utilities.BufferMode \nUtilities.LinearMode \nUtilities.CyclicMode","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.BufferMode","page":"Buffer","title":"Jusdl.Utilities.BufferMode","text":"BufferMode\n\nAbstract type for buffer mode. Subtypes of BufferMode is CyclicMode and LinearMode.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.LinearMode","page":"Buffer","title":"Jusdl.Utilities.LinearMode","text":"LinearMode <: BufferMode\n\nAbstract type of linear buffer modes. See Normal, Lifo, Fifo\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.CyclicMode","page":"Buffer","title":"Jusdl.Utilities.CyclicMode","text":"CyclicMode <: BufferMode\n\nAbstract type of cyclic buffer modes. See Cyclic\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"There are four different buffer modes.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Normal\nCyclic\nLifo \nFifo","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Normal","page":"Buffer","title":"Jusdl.Utilities.Normal","text":"Normal <: LinearMode\n\nLinearMode buffer mode. The data is written to buffer until the buffer is full. When it is full, no more data is written to the buffer. When read, the data written last is returned and the returned data is not deleted from the internal container of the buffer. \n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Cyclic","page":"Buffer","title":"Jusdl.Utilities.Cyclic","text":"Cyclic <: CyclicMode\n\nCyclic buffer mode. The data is written to buffer until the buffer is full. When the buffer is full, new data is written by overwriting the data available in the buffer starting from the beginning of the buffer. When the buffer is read, the element written last is returned and the returned element is not deleted from the buffer.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Lifo","page":"Buffer","title":"Jusdl.Utilities.Lifo","text":"Lifo <: LinearMode\n\nLifo (Last-in-first-out) buffer mode. This type of buffer is a last-in-first-out buffer. Data is written to the buffer until the buffer is full. When the buffer is full, no more element can be written into the buffer. When read, the last element written into buffer is returned. The returned element is deleted from the buffer.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Fifo","page":"Buffer","title":"Jusdl.Utilities.Fifo","text":"Fifo <: LinearMode\n\nFifo (First-in-last-out) buffer mode. This type of buffer is a first-in-first-out buffer. The data is written to the buffer until the buffer is full. When the buffer is full, no more element can be written into the buffer. When read, the first element written into the buffer is returned. The returned element is deleted from the buffer. \n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#Buffer-Constructors-1","page":"Buffer","title":"Buffer Constructors","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"The Buffer construction is very similar to the construction of arrays in Julia. Just specify the mode, element type and length of the buffer. Here are the main Buffer constructors: ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.Buffer","page":"Buffer","title":"Jusdl.Utilities.Buffer","text":"Buffer{M}(::Type{T}, ln::Int) where {M, T}\n\nConstructs a Buffer of length ln with element type of T. M is the mode of the Buffer that determines how data is to read from and written into the Buffer.  There exists for different buffer modes: \n\nNormal: See Normal\nCyclic: See Cyclic\nLifo: See Lifo\nFifo: See Fifo\n\nThe default mode for Buffer is Cyclic and default element type is Float64.\n\nBuffer(::Type{T}, ln::Int) where T\n\nConstructs a Buffer of length ln and with element type of T. The mode of the buffer is Cyclic.\n\nBuffer{M}(ln::Int) where M\n\nConstructs a Buffer of length of ln and with mode M. M can be Normal, Cyclic, Fifo and Lifo. The element type of the Buffer is Float64.\n\nBuffer(ln::Int)\n\nConstructs a Buffer of length ln with mode Cyclic and element type of Float64.\n\n\n\n\n\n","category":"type"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nNote that Buffer is one dimensional. That is, the length of the data must be specified when constructing a Buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nNote that when a Buffer is initialized, the internal data of the Buffer is of missing. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Let us try some examples. Here are some simple buffer construction.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nbuf1 = Buffer{Normal}(Float64, 5)   # Buffer of length `5` with mode `Normal` and element type of `Float64`. \nbuf2 = Buffer{Fifo}(Int, 3)       # Buffer of length `5` with mode `Fifo` and element type of `Int`. \nbuf3 = Buffer(Vector{Int}, 3)       # Buffer of length `5` with mode `Cyclic` and element type of `Vector{Int}`. \nbuf4 = Buffer(Matrix{Float64}, 5)    # Buffer of length `5` with mode `Cyclic` and element type of `Matrix{Float64}`. \nbuf5 = Buffer(5)                    # Buffer of length `5` with mode `Cyclic` and element type of `Float64`.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Note that the element type of Buffer can be any Julia type, even any user-defined type. Note the following example, ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl #hide \nstruct Object end       # Define a dummy type. \nbuf = Buffer{Normal}(Object, 4)  # Buffer of length `4` with element type `Object`.","category":"page"},{"location":"manual/utilities/buffers/#Writing-Data-into-Buffers-1","page":"Buffer","title":"Writing Data into Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Writing data into a Buffer is done with write! function.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"write!","category":"page"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.write!","page":"Buffer","title":"Jusdl.Utilities.write!","text":"write!(buf::Buffer{M, T}, val) where {M, T}\n\nWrites val into buf. Writing is carried occurding the mode M of buf. See Normal, Cyclic, Lifo, Fifo for buffer modes. \n\nExample\n\njulia> buf = Buffer(3)\nBuffer(mode:Cyclic, eltype:Union{Missing, Float64}, length:3, index:1, state:empty)\n\njulia> buf.data  # Initailly all the elements of `buf` is missing.\n3-element Array{Union{Missing, Float64},1}:\n missing\n missing\n missing\n\njulia> write!(buf, 3.)\n3.0\n\njulia> buf.data\n3-element Array{Union{Missing, Float64},1}:\n 3.0     \n  missing\n  missing\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Recall that when the buffer is full, no more data can be written into the buffer if the buffer mode is of type LinearMode. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nnormalbuf = Buffer{Normal}(3)\nfill!(normalbuf, 1.)\nnormalbuf.data \nwrite!(normalbuf, 1.)","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"This situation is the same for Lifo and Fifo buffers, but not the case for Cyclic buffer. ","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl # hide\nnormalbuf = Buffer{Cyclic}(3)\nfill!(normalbuf, 1.)\nnormalbuf.data \nwrite!(normalbuf, 3.)\nwrite!(normalbuf, 4.)","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"warning: Warning\nSince when a Buffer is constructed, it is empty, no data is written to it. But it is initialized with missing data. Thus, the element type of buffer of type Buffer{M, T} where {M, T} is Union{Missing, T} where T. Benchmarks that has been carried out shows that there is no performance bottle neck is such design since Julia's compiler can compile optimized code for such a small unions. Therefore it is possible to write missing into a buffer of type Buffer{M,T} where {M,T}.","category":"page"},{"location":"manual/utilities/buffers/#Reading-Data-from-Buffers-1","page":"Buffer","title":"Reading Data from Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"Reading data from a Buffer is done with read function.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"read","category":"page"},{"location":"manual/utilities/buffers/#Base.read","page":"Buffer","title":"Base.read","text":"read(buf::Buffer)\n\nReads an element from buf. Reading is performed according to the mode of buf. See Normal, Cyclic, Lifo, Fifo for buffer modes. \n\nExample\n\njulia> buf = Buffer{Fifo}(3)\nBuffer(mode:Fifo, eltype:Union{Missing, Float64}, length:3, index:1, state:empty)\n\njulia> for val in 1 : 3. \n       write!(buf, val)\n       @show buf.data\n       end \nbuf.data = Union{Missing, Float64}[1.0, missing, missing]\nbuf.data = Union{Missing, Float64}[1.0, 2.0, missing]\nbuf.data = Union{Missing, Float64}[1.0, 2.0, 3.0]\n\njulia> for i in 1 : 3 \n       item = read(buf)\n       @show (item, buf.data)\n       end\n(item, buf.data) = (1.0, Union{Missing, Float64}[2.0, 3.0, missing])\n(item, buf.data) = (2.0, Union{Missing, Float64}[3.0, missing, missing])\n(item, buf.data) = (3.0, Union{Missing, Float64}[missing, missing, missing])\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#AbstractArray-Interface-of-Buffers-1","page":"Buffer","title":"AbstractArray Interface of Buffers","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"A Buffer can be indexed using the similar syntax of arrays in Julia. That is, getindex and setindex! methods can be used with known Julia syntax. i.e. getindex(buf, idx) is equal to buf[idx] and setindex(buf, val, idx) is equal to buf[idx] = val.","category":"page"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"using Jusdl  # hide\nbuf = Buffer(5)\nsize(buf)\nlength(buf)\nfor val in 1 : 5 \n    write!(buf, 2val)\nend \nbuf[1]\nbuf[3:4]\nbuf[[3, 5]]\nbuf[end]\nbuf[1] = 5 \nbuf[3:5] = [7, 8, 9]","category":"page"},{"location":"manual/utilities/buffers/#Full-API-1","page":"Buffer","title":"Full API","text":"","category":"section"},{"location":"manual/utilities/buffers/#","page":"Buffer","title":"Buffer","text":"fill!\nisempty\nisfull\ncontent","category":"page"},{"location":"manual/utilities/buffers/#Base.fill!","page":"Buffer","title":"Base.fill!","text":"fill!(buf::Buffer{M, T}, val::T) where {M,T}\n\nWrites val into buf until buf is full.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Base.isempty","page":"Buffer","title":"Base.isempty","text":"isempty(buf::Buffer)\n\nReturns true if buf is empty.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.isfull","page":"Buffer","title":"Jusdl.Utilities.isfull","text":"isfull(buf::Buffer)\n\nReturns true if buf is full.\n\n\n\n\n\n","category":"function"},{"location":"manual/utilities/buffers/#Jusdl.Utilities.content","page":"Buffer","title":"Jusdl.Utilities.content","text":"content(buf, [flip=true])\n\nReturns the current data of buf. If flip is true, the data to be returned is flipped. \n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Busses-1","page":"Busses","title":"Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"A Bus is actually is a bunch of links. Reading from and writing into  data is performed as in the case of Links.","category":"page"},{"location":"manual/connections/bus/#Construction-of-Bus-1","page":"Busses","title":"Construction of Bus","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"A Bus is constructed by specifying its element type T, number of links nlinks and the buffer length of its links.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Bus","category":"page"},{"location":"manual/connections/bus/#Jusdl.Connections.Bus","page":"Busses","title":"Jusdl.Connections.Bus","text":"Bus{T}([nlinks::Int=1, [ln::Int=64]]) where T\n\nConstructs a Bus consisting of nlinks links. ln is the buffer length and T is element type of the links.\n\n\n\n\n\n","category":"type"},{"location":"manual/connections/bus/#Connection-and-Disconnection-of-Busses-1","page":"Busses","title":"Connection and Disconnection of Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"The Busses can be connected and disconnected to each other. When connected any data written to the master bus is also written all slave busses. See the following example.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Let us connect two busses and connect them together.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"using Jusdl # hide\nb1 = Bus(2, 5)  # Bus with `2` links with buffer length of `5`.\nb2 = Bus(2, 5)  # Bus with `2` links with buffer length of `5`.\nconnect(b1, b2)","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Here, b1 is the master bus and b2 is the slave bus. That is, data written to b1 is also written into b2.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"t1 = launch(b1);\nt2 = launch(b2);\nput!(b1, [5., 10.]);\n[b1[i].buffer.data for i = 1 : 2]\n[b2[i].buffer.data for i = 1 : 2]","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Note that the data [5, 10] written to b1 is also written b2 since they are connected.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"The Busses connected to each other can be disconnected. When disconnected, the data written to master is not written to slaves","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"disconnect(b1, b2)\nisconnected(b1, b2)","category":"page"},{"location":"manual/connections/bus/#Data-Flow-through-Busses-1","page":"Busses","title":"Data Flow through Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Data flow through the Busses is very similar to the case in Links. See Data Flow through Links for information about data flow through Links. Runnable tasks must be bound to the links of the busses for data flow through the Bus. Again, put! and take! functions are used to write data from a Bus and read from data from a Bus.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Connections.put!(bus::Bus, vals)\nConnections.take!(bus::Bus)","category":"page"},{"location":"manual/connections/bus/#Base.put!-Tuple{Bus,Any}","page":"Busses","title":"Base.put!","text":"put!(bus::Bus, vals)\n\nPuts vals to bus. Each item in vals is putted to the links of the bus.\n\nwarning: Warning\nThe bus must be writable to be read. That is, there must be a runnable tasks bound to links of the bus that reads data from bus. See launch\n\nExample\n\njulia> b = Bus(2);\n\njulia> t = launch(b);\n\njulia> put!(b, [1., 2.])\n┌ Info: Took \n└   val = 1.0\n┌ Info: Took \n└   val = 2.0\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.take!-Tuple{Bus}","page":"Busses","title":"Base.take!","text":"take!(bus::Bus)\n\nTakes an element from bus. Each link of the bus is a read and a vector containing the results is returned.\n\nwarning: Warning\nThe bus must be readable to be read. That is, there must be a runnable tasks bound to links of the bus that writes data to bus. See launch\n\nExample\n\njulia> b = Bus(2);\n\njulia> t = launch(b, [[rand() for i = 1 : 5] for j = 1 : 2])\n2-element Array{Task,1}:\n Task (runnable) @0x00007f9634734280\n Task (runnable) @0x00007f96347344f0\n\njulia> take!(b)\n2-element Array{Float64,1}:\n 0.6216364091492494\n 0.0781964275368685\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Any data written to a Bus is recorded into the buffers of its links.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"@repl writing_to_busses\nusing Jusdl # hide\nb = Bus(2, 5);\nlaunch(b);\nput!(b, 1.);\nb[1].buffer.data","category":"page"},{"location":"manual/connections/bus/#Indexing-and-Iteration-of-Busses-1","page":"Busses","title":"Indexing and Iteration of Busses","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Busses can be indexed similarly to the arrays in Julia. When indexed, corresponding link of the bus is returned.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"using Jusdl # hide \nb = Bus(3) \nb[1]\nb[end] \nb[:]\nb[1] = Link()\nb[1:2] = [Link(), Link()]","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"The iteration of Busses in a loop is also possible. When iterated, the links of the Bus is returned.","category":"page"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"using Jusdl # hide \nbus = Bus(3)\nfor link in bus\n    @show link\nend","category":"page"},{"location":"manual/connections/bus/#Full-API-1","page":"Busses","title":"Full API","text":"","category":"section"},{"location":"manual/connections/bus/#","page":"Busses","title":"Busses","text":"Connections.eltype\nConnections.length\nConnections.iterate\nConnections.hasslaves(bus::Bus)\nConnections.hasmaster(bus::Bus)\nConnections.close(bus::Bus)\nConnections.isfull(bus::Bus)\nConnections.isreadable(bus::Bus)\nConnections.iswritable(bus::Bus)\nConnections.snapshot(bus::Bus)\nConnections.launch(bus::Bus)\nConnections.launch(bus::Bus, valrange::AbstractVector)\nConnections.getindex\nConnections.setindex!","category":"page"},{"location":"manual/connections/bus/#Base.eltype","page":"Busses","title":"Base.eltype","text":"eltype(bus::Bus)\n\nReturns the element type of bus. Element type of bus is a subtype of Link.\n\nExample\n\njulia> b = Bus{Matrix{Float64}}(5)\nBus(nlinks:5, eltype:Array{Float64,2}, isreadable:false, iswritable:false)\n\njulia> eltype(b)\nLink{Union{Missing, Array{Float64,2}}}\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Base.length","page":"Busses","title":"Base.length","text":"length(bus::Bus)\n\nReturns the number of links in bus.\n\nExample\n\njulia> b = Bus(5)\nBus(nlinks:5, eltype:Float64, isreadable:false, iswritable:false)\n\njulia> length(b)\n5\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Base.iterate","page":"Busses","title":"Base.iterate","text":"iterate(bus::Bus[, i=1])\n\nİteration interface so that bus can be iterated in a loop. The links of bus are iterated.\n\nExample\n\njulia> b = Bus(3);\n\njulia> for l in b \n       @show l \n       end\nl = Link(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\nl = Link(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\nl = Link(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n\n\n\n\n\niterate(clk::Clock[, t=clk.t)\n\nIterationk interface for clk. clk can be iterated in a loop.\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.3);\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.3, paused:false, isrunning:true)\n\njulia> for t in clk\n       @show t \n       end\nt = 0.0\nt = 0.1\nt = 0.2\nt = 0.3\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Jusdl.Connections.hasslaves-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.hasslaves","text":"hasslaves(bus:Bus)\n\nReturns true is all the links of bus has slaves. See also hasslaves(link::Link)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.hasmaster-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.hasmaster","text":"hasmaster(bus::Bus) \n\nReturns true is all the links of bus has master. See alsos hasmaster(link::Link)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.close-Tuple{Bus}","page":"Busses","title":"Base.close","text":"close(bus::Bus)\n\nCloses bus. When closed, no more data flow is possible for bus. \n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.isfull-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.isfull","text":"isfull(bus::Bus)\n\nReturns true when the links of bus are full.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.isreadable-Tuple{Bus}","page":"Busses","title":"Base.isreadable","text":"isreadable(bus::Bus)\n\nReturns true if all the links of bus is readable.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.iswritable-Tuple{Bus}","page":"Busses","title":"Base.iswritable","text":"iswritable(bus::Bus)\n\nReturns true if all the links of bus is writable.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.snapshot-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.snapshot","text":"snapshot(bus::Bus)\n\nReturns all the data in links of bus.\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.launch-Tuple{Bus}","page":"Busses","title":"Jusdl.Connections.launch","text":"launch(bus::Bus)\n\nLaunches every link of bus. See launch(link::Link)\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Jusdl.Connections.launch-Tuple{Bus,AbstractArray{T,1} where T}","page":"Busses","title":"Jusdl.Connections.launch","text":"launch(bus::Bus, valrange::AbstractVector)\n\nLaunches every links of bus with every item of valrange. See [launch(link:Link, valrange)(@ref)]\n\n\n\n\n\n","category":"method"},{"location":"manual/connections/bus/#Base.getindex","page":"Busses","title":"Base.getindex","text":"getindex(bus::Bus, I)\n\nReturns the links of bus corresponding to I. The syntax bus[I] is the same as getindex(bus, I).\n\nExample\n\njulia> b = Bus(3);\n\njulia> b[1]\nLink(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n\njulia> b[1:2]\n2-element Array{Link{Union{Missing, Float64}},1}:\n Link(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n Link(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n\njulia> b[end]\nLink(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n\n\n\n\n\n","category":"function"},{"location":"manual/connections/bus/#Base.setindex!","page":"Busses","title":"Base.setindex!","text":"setindex!(bus::Bus, val, I::Int)\n\nSets val to the links of bus corresponding to index I. The syntax bus[I] = val is the same as setindex!(bus, val, I).\n\nExample\n\njulia> b = Bus(5);\n\njulia> b[2:3] .= [Link() for i = 1 : 2]\n2-element Array{Link{Union{Missing, Float64}},1}:\n Link(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n Link(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n\njulia> b[end] = Link() \nLink(state:open, eltype:Union{Missing, Float64}, hasmaster:false, numslaves:0, isreadable:false, iswritable:false)\n\n\n\n\n\n","category":"function"},{"location":"#Jusdl-1","page":"Home","title":"Jusdl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is the official documentation of Jusdl that enables fast and effective systems simulations together with online and offline data analysis. In Jusdl, it is possible to simulate discrete time and continuous time, static or dynamical systems. In particular, it is possible to simulate dynamical systems modeled by different types of differential equations such as ODE (Ordinary Differential Equation), Random Ordinary Differential Equation (RODE), SDE (Stochastic Differential Equation), DDE (Delay Differential Equation) and DAE (Differential Algebraic Equation), and discrete difference equations. During the simulation, the data flowing through the links of the model can processed online and offline and specialized analyzes can be performed. These analyzes can also be enriched with plugins that can easily be defined using the standard Julia library or various Julia packages. The simulation is done with the parallel evolution of the model components individually and sampling sampling time intervals. The individual evolution of the components allows the simulation of the models including the components that are represented by different kinds of mathematical equations while the parallel evolution of components increases the simulation speed. ","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Installation of Jusdl is the similar to any Julia package. Just add from the repository [https://imel.eee.deu.edu.tr/git/JuSDL.jl.git]. Start a Julia session and type,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg \nPkg.add(PackageSpec(url=\"https://imel.eee.deu.edu.tr/git/JuSDL.jl.git\"))","category":"page"},{"location":"#Modelling-and-Simulation-in-Jusdl-1","page":"Home","title":"Modelling and Simulation in Jusdl","text":"","category":"section"},{"location":"#Modelling-1","page":"Home","title":"Modelling","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There exist different approaches in modeling of systems such as process-based, physical- interaction and signal-flow. Signal flow approach is the one that is used in JuSDL. In this approach, a model comprises of components and busses. Links connect the components to each other. The components are data processing units and it is the behavior of the component that determines how the data is processed. The component behavior is defined by the mathematical equations obtained as a result of the physical laws that the physical quantities used in the modeling of the component must comply. Depending upon the nature of the system and the modeling, these equations may change, i.e. they may or may not contain derivative terms, or they may contain the continuous time or discrete time variable, etc. The components interact themselves through their input-output busses. The data-flow through the busses is unidirectional, i.e., a component is driven by other components that write data to its input bus.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Model simulation is performed by evolving the components individually. To make the components have a common time base, a common time reference is used. The time reference generates pulses at simulation sampling intervals and writes these pulses to the trigger links of the components to trigger them. Each component that is triggered read its input data from its input bus, calculates its output according to its output model and writes it to its output bus.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<center>\n    <img src=\"assets/model.png\" alt=\"model\" width=\"50%\"/>\n</center>","category":"page"},{"location":"#Components-1","page":"Home","title":"Components","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The component types in JuSDL are shown in Figure 2.2 together with output and state equations. The components can be grouped as sources, sinks, and systems. The sources are components that generate signals as functions of time. Having been triggered, a source computes its output according to its output function and writes it to its output bus. The sources do not have input busses as their outputs depend only on time. The sinks are data processing units. Their primary objectives are to process the data flowing through the busses of the model online. Having been triggered, a sink reads its input data and process them, i.e. data can be visualized by being plotted on the graphical user interface, can be observed by being printed on the console, can be stored on data files. The data processing capability of the sinks can be enriched by integrating new plugins that can be developed using the standard Julia library or various available Julia packages. For example, invariants, spectral properties or statistical information can be derived from the data, parameter estimation can be performed or various signal processing techniques can be applied on the data. JuSDL has been designed to be flexible enough to allow one to enlarge the scope of its available plugins by integrating newly-defined ones.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<center>\n    <img src=\"assets/components.png\" alt=\"model\" width=\"50%\"/>\n</center>","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As the output of a static system depends on input and time, a static system is de- fined by an output equation. Having been triggered, a static system reads its input data, calculates its output according to its output function and writes it to its output bus. In dynamic systems, however, system behavior is characterized by states and output of a dynamic system depends on input, previous state and time. Therefore, a dynamic system is defined by a state equation and an output equation. When triggered, a dynamic system reads its input, update its state according to its state equation, calculates its output according to its output equation and writes its output to its output bus. JuSDL is capable of simulating the dynamic systems with state equations in the form of the ordinary differential equation(ODE), differential algebraic equation(DAE), random ordinary differential equation(RODE), stochastic differential equation(SDE), delay differential equation(DDE) or discrete difference equation. Most of the available simulation environments allow the simulation of systems represented by ordinary differential equations or differential algebraic equations. Therefore, analyzes such as noise analysis, delay analysis or random change of system parameters cannot be performed in these simulation environments. On the contrary, JuSDL makes it possible for all these analyses to be performed owing to its ability to solve such a wide range of state equations.","category":"page"},{"location":"#Busses-1","page":"Home","title":"Busses","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Busses consist of bunches of links. Links are built upon channels that are defined in standard Julia library. The data written to(read from) the busses is written to(read from) the links which are then written to(read from) the channels. Active Julia tasks that are bound to channels must exist for data to flow over these channels. Ju- lia tasks are control flow features that allow calculations to be flexibly suspended and maintained without directly communicating the task scheduler of the operating system. Communication and data exchange between the tasks are carried out through Julia channels to which they are bound. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<head>\n    <style>\n    * {\n    box-sizing: border-box;\n    }\n\n    .column {\n    float: left;\n    width: 33.33%;\n    padding: 5px;\n    }\n\n    /* Clearfix (clear floats) */\n    .row::after {\n    content: \"\";\n    clear: both;\n    display: table;\n    }\n\n    /* Responsive layout - makes the three columns stack on top of each other instead of next to each other */\n    @media screen and (max-width: 500px) {\n    .column {\n        width: 100%;\n    }\n    }\n    </style>\n</head>\n\n<body>\n    <div class=\"row\">\n        <div class=\"column\">\n            <img src=\"assets/reader_task.png\" alt=\"reader_task\" style=\"width:100%\">\n        </div>\n        <div class=\"column\">\n            <img src=\"assets/writer_task.png\" alt=\"writer_task\" style=\"width:100%\">\n        </div>\n        <div class=\"column\">\n            <img src=\"assets/reader_writer_task.png\" alt=\"reader_writer_task\" style=\"width:100%\">\n        </div>\n    </div>\n</body>","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In the figure above are shown symbolically the tasks that must be bound to the channel to make a channel readable, writable and both readable and writable. The putter and the taker task is the task that writes data to and reads data from the channel, respectively. To be able to read data from one side of the channel, an active putter task must be bound to the chan- nel at the other side of the channel, and the channel is called a readable channel. Similarly, to be able to write data to one side of the channel, an active taker task must be bound to the channel at the other side, and the channel is called a writable channel. If both active putter and taker tasks are bound to either side of the channel, then the data can both be read from and written to the channel, and the channel is called a both readable and writable channel. The data-flow through the channel is only achieved if the channel is both readable and writable channel. The data read from a readable channel is the data written to the channel by the putter task of the channel. If data has not been written yet to the channel by the putter task of the channel during a reading process, then reading does not occur and the putter task is waited to put data to the channel. Similarly, if the data on the channel has not been read yet from the channel by the taker task during a writing process, then the taker task is waited to take data from the channel. In the modeling approach adopted, the components reading data from a bus are driven by other components writing data to the bus. Therefore, all of the busses of the model must be both readable and writable busses so that data can flow the busses. This means that all the busses of the model must be connected to a component from both ends. Otherwise, the simulation gets stuck and does not end during a reading process from a channel that is not connected to a component. During the simulation, the busses can be arranged as desired, the gain of the busses can be changed, new busses can be added or an existing bus can be broken. In other words, the structure of the system being simulated can change dynamically. This allows one to perform topological studies such as the investigation of the effects of change in the topology of a network or the change o coupling strengths on the behavior of the network.","category":"page"},{"location":"#Simulation-1","page":"Home","title":"Simulation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A model to be simulated consists of components connected to each other and a time reference. The time reference is used to sample the continuous time signals flowing through the busses of the model and to trigger the components. The simulation is performed by triggering the components with pulses generated by the time reference at simulation sampling time intervals. Having been triggered, the components evolve themselves, compute their outputs and writes them to their output busses.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simulation stages are shown in the flowchart in Figure 2.4. In the first stage, the model is inspected in terms of whether it has unterminated bussed, etc. In case an unterminated bus is inspected, then the simulation is terminated directly. It is also possible to enlarge the scope of the inspection stage to determine whether the model includes algebraic loops, etc.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If the inspection stage results positive, the initialization stage comes next. In this stage, the tasks required for the busses of the model to be both readable and writable are activated and bound to the busses. To this end, a putter and a taker task are activated and bound to both sides of each bus. For example, in Figure 2.5a is shown a part of a model consisting of the components B1, B2, B3, B4 and busses L1, L2, L3. When triggered, B1(B2) reads data from L1(L2) and writes data to L2(L3). The tasks that are bound on L1 and L2 are shown symbolically in Figure 2.5b. A taker and a putter task are bound to L1 and L2, respectively, corresponding to B1. Similarly, a taker and a putter task are bound to L2 and L3, respectively, corresponding to B2. As a putter task and a taker task is bound to L2, data-flow from B1 to B2 is possible through it.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The run stage follows the initialization stage. The tasks activated in initialization stage wait for the components to be triggered by the model time reference. During the run stage, time reference triggers the components by writing pulses that are generated in the intervals of the sampling period of the simulation to their trigger links. The job defined in a task is to read input data from its input bus, to calculate its next state—if any—and output, and to write its output to its output bus. The run stage starts at the initial time of the time reference and continues until the end time of the time reference.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After the run stage, the tasks opened in the initialization stage are closed and the simulation is terminated.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In some simulation environments, a unified mathematical equation represent- ing the model as a whole is obtained and solved in just a single shot for the entire simulation duration, even if the model is thought to consist of components[13]. In JuSDL, a model is, again, thought to consist of components, but is not represented by a unified mathematical equation. Instead, the model is evolved by evolving the components individually by solving their own mathematical equations. The components do not evolve in one shot, but instead, they evolve in parallel for during the time intervals between subsequent sampling instants. Here, it worths noting that the type of the mathematical equations of the components of a model does not have to be the same. Thus, JuSDL allows the simulation of the models consisting of components represented by different types of mathematical equations.","category":"page"},{"location":"#Table-of-Contents-1","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"manual/utilities/callback.md\"\n    \"manual/utilities/buffers.md\"\n    ]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"manual/connections/link.md\",\n    \"manual/connections/bus.md\"\n    ]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"manual/components/sources/clock.md\",\n    \"manual/components/sources/generators.md\",\n    ]","category":"page"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"manual/components/sources/clock/#Clock-1","page":"Clock","title":"Clock","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Jusdl is a clocked simulation environment. That is, model components are evolved in different time intervals, called as sampling interval. During the simulation, model components are triggered by these generated time pulses.  The Clock type is used to to generate those time pulses. The simulation time settings, the simulation start time, stop time, sampling interval are configured through the Clocks.","category":"page"},{"location":"manual/components/sources/clock/#Construction-of-Clock-1","page":"Clock","title":"Construction of Clock","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Construction of Clock is done by specifying its start time and final time and the simulation sampling period. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Clock","category":"page"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.Clock","page":"Clock","title":"Jusdl.Components.Sources.Clock","text":"Clock(t::Real, dt::Real, tf::Real)\n\nConstructs a Clock with starting time t, final time tf and sampling inteval dt. When iterated, the Clock returns its current time. \n\nwarning: Warning\nWhen constructed, Clock is not running. To take clock ticks from Clock, the Clock must be setted. See take!(clk::Clock) and set! \n\n\n\n\n\n","category":"type"},{"location":"manual/components/sources/clock/#Basic-Usage-of-Clocks-1","page":"Clock","title":"Basic Usage of Clocks","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"A Clock instance has a Callback list so that a Callback can be constructed to trigger specific events configured with the time settings. See the following case study. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Let us consider a Clock with initial time of 0, sampling interval of 1 and final time of 10.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"using Jusdl # hide \nclk = Clock(0., 1., 10.)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Notice that clk is not running, since it is not set. Now, let us set it","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"set!(clk)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"clk is ready to run, i.e., to be iterated. The following commands generated clock ticks and shows it on the console.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"for t in clk \n    @show t \nend","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"At this point, clk is out of time. The current time of clk does not advance any more. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"take!(clk)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"But, clk can be reset again.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"set!(clk, 0., 1., 10.)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Consider that we want to configure and alarm. For this, let us consider that when the time of clk is greater than 5 an alarm message is printed on console. To this end, we need to construct a Callback and add it to the callbacks of clk. (When constructed callback list of clk is empty.)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"condition(clk) = clk.t > 5\naction(clk) = println(\"Clock time = \", clk.t)\ncallback = Callback(condition, action)\naddcallback(clk, callback)","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Now, let us run clk by iterating it. ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"for t in clk \n    @show t \nend ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Note that we, constructed a simple callback. It is of course possible to construct more complex callbacks.","category":"page"},{"location":"manual/components/sources/clock/#Usage-of-Clocks-with-ProgressMeter-1","page":"Clock","title":"Usage of Clocks with ProgressMeter","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"It also possible to iterate the Clocks by using a progress meter. See ProgressMeter for further information for progress meter.","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"using Jusdl\nusing ProgressMeter\nclk = Clock(0., 0.01, 1.)\nset!(clk)\n@showprogress for t in clk \nend ","category":"page"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"Note that clk is just iterated.","category":"page"},{"location":"manual/components/sources/clock/#Full-API-1","page":"Clock","title":"Full API","text":"","category":"section"},{"location":"manual/components/sources/clock/#","page":"Clock","title":"Clock","text":"take!(clk::Clock)\nisrunning\nispaused\nisoutoftime\nset!\nstop!\npause!\niterate(clk::Clock)","category":"page"},{"location":"manual/components/sources/clock/#Base.take!-Tuple{Clock}","page":"Clock","title":"Base.take!","text":"take!(clk::Clock)\n\nTakes a values from clk.\n\nExample\n\nulia> clk = Clock(0., 0.1, 0.5)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:false)\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:true)\n\njulia> for i = 0 : 5 \n       @show take!(clk)\n       end\ntake!(clk) = 0.0\ntake!(clk) = 0.1\ntake!(clk) = 0.2\ntake!(clk) = 0.3\ntake!(clk) = 0.4\ntake!(clk) = 0.5\n\n\n\n\n\n","category":"method"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.isrunning","page":"Clock","title":"Jusdl.Components.Sources.isrunning","text":"isrunning(clk::Clock)\n\nReturns true if clk if clk is running.\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.ispaused","page":"Clock","title":"Jusdl.Components.Sources.ispaused","text":"ispaused(clk::Clock)\n\nReturns true if clk is paused. When paused, the currnent time of clk is not advanced. See also pause!(clk::Clock)\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.isoutoftime","page":"Clock","title":"Jusdl.Components.Sources.isoutoftime","text":"isoutoftime(clk::Clock)\n\nReturns true if clk is out of time, i.e., the current time of clk exceeds its final time. \n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.set!","page":"Clock","title":"Jusdl.Components.Sources.set!","text":"set(clk::Clock, t::Real, dt::Real, tf::Real)\n\nSets clk for current clock time t, sampling time dt and final time tf. After the set,  it is possible to take clock tick from clk. See also take!(clk::Clock)\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.5)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:false)\n\njulia> take!(clk)\n┌ Warning: Clock is not running.\n└ @ Jusdl.Components.Sources ~/.julia/dev/Jusdl/src/components/sources/clock.jl:47\n0.0\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:true)\n\njulia> take!(clk)\n0.0\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.stop!","page":"Clock","title":"Jusdl.Components.Sources.stop!","text":"stop!(clk::Clock)\n\nUnsets clk. After the stpp, it is possible to take clock ticks from clk. See also take!(clk::Clock)\n\nExample\n\njulia> clk\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:false)\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:true)\n\njulia> take!(clk)\n0.0\n\njulia> stop!(clk)\nClock(t:0.0, dt:0.1, tf:0.5, paused:false, isrunning:false)\n\njulia> take!(clk)\n┌ Warning: Clock is not running.\n└ @ Jusdl.Components.Sources ~/.julia/dev/Jusdl/src/components/sources/clock.jl:47\n0.0\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Jusdl.Components.Sources.pause!","page":"Clock","title":"Jusdl.Components.Sources.pause!","text":"pause!(clk::Clock)\n\nPauses clk. When paused, the current time of clk does not advance.\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.5);\n\njulia> set!(clk);\n\njulia> for i = 1 : 5\n       i > 3 && pause!(clk)\n       @show take!(clk)\n       end\n\ntake!(clk) = 0.0\ntake!(clk) = 0.1\ntake!(clk) = 0.2\n┌ Warning: Clock is paused.\n└ @ Jusdl.Components.Sources ~/.julia/dev/Jusdl/src/components/sources/clock.jl:58\ntake!(clk) = 0.2\n┌ Warning: Clock is paused.\n└ @ Jusdl.Components.Sources ~/.julia/dev/Jusdl/src/components/sources/clock.jl:58\ntake!(clk) = 0.2\n\n\n\n\n\n","category":"function"},{"location":"manual/components/sources/clock/#Base.iterate-Tuple{Clock}","page":"Clock","title":"Base.iterate","text":"iterate(clk::Clock[, t=clk.t)\n\nIterationk interface for clk. clk can be iterated in a loop.\n\nExample\n\njulia> clk = Clock(0., 0.1, 0.3);\n\njulia> set!(clk)\nClock(t:0.0, dt:0.1, tf:0.3, paused:false, isrunning:true)\n\njulia> for t in clk\n       @show t \n       end\nt = 0.0\nt = 0.1\nt = 0.2\nt = 0.3\n\n\n\n\n\n","category":"method"}]
}

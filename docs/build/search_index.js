var documenterSearchIndex = {"docs":
[{"location":"manual/buffers/#Buffer-1","page":"Buffer","title":"Buffer","text":"","category":"section"},{"location":"manual/buffers/#","page":"Buffer","title":"Buffer","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/buffers/#","page":"Buffer","title":"Buffer","text":"Buffer","category":"page"},{"location":"#Jusdl-1","page":"Jusdl","title":"Jusdl","text":"","category":"section"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"This is the official documentation of Jusdl that enables fast and effective systems simulations together with online and offline data analysis. In Jusdl, it is possible to simulate discrete time and continuous time, static or dynamical systems. In particular, it is possible to simulate dynamical systems modeled by different types of differential equations such as ODE (Ordinary Differential Equation), Random Ordinary Differential Equation (RODE), SDE (Stochastic Differential Equation), DDE (Delay Differential Equation) and DAE (Differential Algebraic Equation), and discrete difference equations. During the simulation, the data flowing through the links of the model can processed online and offline and specialized analyzes can be performed. These analyzes can also be enriched with plugins that can easily be defined using the standard Julia library or various Julia packages. The simulation is done with the parallel evolution of the model components individually and sampling sampling time intervals. The individual evolution of the components allows the simulation of the models including the components that are represented by different kinds of mathematical equations while the parallel evolution of components increases the simulation speed. ","category":"page"},{"location":"#Table-of-Contents-1","page":"Jusdl","title":"Table of Contents","text":"","category":"section"},{"location":"#","page":"Jusdl","title":"Jusdl","text":"Pages = [\n    \"manual/callback.md\"\n    ]","category":"page"},{"location":"manual/callback/#Callback-1","page":"Callback","title":"Callback","text":"","category":"section"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"DocTestSetup  = quote\n    using Jusdl\nend","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"Callbacks are used to monitor the existence of a specific events and if that specific event occurs, some other special jobs are invoked. Callbacks are intended to provide additional monitoring capability to any user-defined composite types. As such, Callbacks are generaly fields of user defined composite types objects. When a Callback is called, if the Callback is enabled and its condition function returns true, then its action function is invoked. ","category":"page"},{"location":"manual/callback/#A-Simple-Example-1","page":"Callback","title":"A Simple Example","text":"","category":"section"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"Let's define a test object first that has a field named x of type Int and named callback of type Callback. ","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"julia> mutable struct TestObject\n       x::Int\n       callback::Callback\n       end","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"To construct an instance of TestObject, we need to construct a Callback. For that purpose, condition and action function must be defined. For this example, condition checks whether the x field is positive, and action prints a simple message saying that the x field is positive.","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"julia> condition(testobject) = testobject.x > 0 \ncondition (generic function with 1 method)\n\njulia> action(testobject) = println(\"testobject.x is greater than zero\") \naction (generic function with 1 method)","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"Now a test object can be constructed","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"julia> testobject = TestObject(-1, Callback(condition, action))  \nTestObject(-1, Callback{typeof(condition),typeof(action)}(condition, action, true, \"dac6f9eb-6daa-4622-a8fa-623f0f88780c\"))","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"If the callback is called, no action is performed since the condition function returns false. Note the argument sent to the callback. The instance of the TestObject to which the callback is a bound.","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) ","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"Now mutate the test object so that condition returns true.","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.x = 3   \n3","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"Now, if the callback is called, since the condition returns true and the callback is enabled, the action is invoked.","category":"page"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"julia> testobject.callback(testobject) \ntestobject.x is greater than zero","category":"page"},{"location":"manual/callback/#Full-API-1","page":"Callback","title":"Full API","text":"","category":"section"},{"location":"manual/callback/#","page":"Callback","title":"Callback","text":"Callback\nenable!\ndisable!\naddcallback\ndeletecallback","category":"page"},{"location":"manual/callback/#Jusdl.Utilities.Callback","page":"Callback","title":"Jusdl.Utilities.Callback","text":"Callback(condition, action)\n\nConstructs a Callback from condition and action. The condition and action must be a single-argument functions. condition returns true if the condition it checks occurs, otherwise ite returns false. action is performs the specific action for which the Callback the callback is contructed. A Callback can be called by passing its single argument which is mostly bound to the Callback.\n\nExample\n\njulia> struct Object  # Define a dummy type.\n       x::Int \n       clb::Callback \n       end \n\njulia> cond(obj) = obj.x > 0  # Define callback condition.\ncond (generic function with 1 method)\n\njulia> action(obj) = println(\"Printing the object \", obj) # Define callback action.\naction (generic function with 1 method)\n\njulia> obj = Object(1, Callback(cond, action))  # Construct an `Object` instance with `Callback`.\nObject(1, Callback(condition:cond, action:action))\n\njulia> obj.clb(obj)  # Call the callback bound `obj`.\nPrinting the object Object(1, Callback(condition:cond, action:action))\n\n\n\n\n\n","category":"type"},{"location":"manual/callback/#Jusdl.Utilities.enable!","page":"Callback","title":"Jusdl.Utilities.enable!","text":"enable!(clb::Callback)\n\nEnables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/callback/#Jusdl.Utilities.disable!","page":"Callback","title":"Jusdl.Utilities.disable!","text":"disable!(clb::Callback)\n\nDisables clb.\n\n\n\n\n\n","category":"function"},{"location":"manual/callback/#Jusdl.Utilities.addcallback","page":"Callback","title":"Jusdl.Utilities.addcallback","text":"addcallback(obj, clb::Callback, priority::Int)\n\nAdds clb to callback vector of obj which is assumed the have a callback list which is a vector of callback.\n\nExample\n\njulia> mutable struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       Object(x::Int) = new(x, Callback[])\n       end \n\njulia> obj = Object(5)\nObject(5, Callback[])\n\njulia> condition(val) = val.x == 5\ncondition (generic function with 1 method)\n\njulia> action(val) = @show val.x \naction (generic function with 1 method)\n\njulia> addcallback(obj, Callback(condition, action))\nObject(5, Callback[Callback(condition:condition, action:action)])\n\njulia> obj.callbacks(obj)\nval.x = 5\n\n\n\n\n\n","category":"function"},{"location":"manual/callback/#Jusdl.Utilities.deletecallback","page":"Callback","title":"Jusdl.Utilities.deletecallback","text":"deletecallback(obj, idx::Int)\n\nDeletes the one of the callbacks of obj at index idx.\n\njulia> struct Object \n       x::Int \n       callbacks::Vector{Callback}\n       end\n\njulia> clb1 = Callback(val -> true, val -> nothing);\n\njulia> clb2 = Callback(val -> false, val -> nothing);\n\njulia> obj = Object(5, [clb1, clb2]);\n\njulia> deletecallback(obj, 2);\n\njulia> length(obj.callbacks) == 1\ntrue\n\n\n\n\n\n","category":"function"}]
}

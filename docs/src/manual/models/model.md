# Model 

## Signal-Flow Approach in Modelling 
`Jusdl` adopts *signal-flow* approach in systems modelling. In signal-flow approach, a `Model` consists of connected components. The components are data processing units and the behavior, i.e, the mathematical model, of the component determines how the data is processed. Connections connects the components each other and the data is transferred between components by means of connections. The data flow through the connections is unidirectional, i.e., a component is driven by other components that write data to its input bus. 

## Construction of Models
A `Model` consists of connected components. Here is the constructor, 
```@docs 
Model
```
That is, the components of are defined first and the `Model` consisting of these components can be constructed. Or, an empty model can be constructed. 

Let us continue with some examples. We will construct very simple `Model` consisting of a [`SinewaveGenerator`](@ref) and a [`Writer`](@ref). We construct the components first.
```@repl model_construction_ex 
using Jusdl # hide 
gen = SinewaveGenerator()
writer = Writer(Bus())
```
Next, we construct the model
```@repl model_construction_ex 
model = Model(gen, writer)
```

The other way is to construct an empty `Model`, that is a `Model` with no components, and then add components later. 
```@repl model_construction_ex_2
using Jusdl # hide 
model = Model()
addcomponent(model, SinewaveGenerator())
addcomponent(model, Writer())
```

## Simulation of Models 

A `Model` to to be simulated consists of components connected to each other an a time reference.
```@repl model_construction_ex_2
model.blocks    # Model components 
model.clk       # Model time reference
```
The time reference is used to sample the continuous time signals flowing through the busses of the model and to rigger the components. The simulation is performed by triggering the components with the pulses generated by the time reference at simulation sampling time intervals. Having been triggered, the components evolve themselves, compute their outputs and writes them to their outputs.

### Simulation Stages 

#### Inspection
The inspection stage is the first stage of the simulation process. In this stag,e the model is first inspected in terms of whether it is ready for simulation. This inspection is carried out to see whether the model has some inconsistencies such as unterminated busses or presence of algebraic loops. If the model has unterminated busses, the data that is supposed to flow those unterminated busses cannot flow through those busses and the simulation gets stuck. An algebraic is the subset of model components whose output depends directly on their inputs. In such a case, none of the components can produce outputs to break the loop which leads again the obstruction of simulation. Thus, to continue the simulation, the model must not contain any of those inconsistencies. The model inspection is done with `inspect` function.

```@docs
inspect
```

#### Initialization 

If the inspection stage results positive, the initialization stage comes next. In this stage, the tasks required for the busses of the model to be both readable and writable are activated and bound the busses. To this end, a reader and writer task are activated and bound to both sides of each bus. To initialize the model, `initialize` function is used. 

```@docs 
initialize
```

When the model is initialized, the pairs of components and component tasks are recorded into the task manager of the model. During the rest of the simulation, task manager keeps track of the tasks. Any exception or error that is thrown during the run stage of the simulation can be observed by means of the task manager of the model.

#### Run 
The run stage follows the initialization stage. The tasks activated in the initialization stage wait for the components to be triggered by the model time reference. During the run stage, time reference, that is the model clock, triggers the components by writing pulses that are generated in the intervals of the sampling period of the simulation to their trigger links. The job defined in a task is to read input dat a from the its input bus, to calculate its next state, if any, and output, and write its calculated output to its output bus. The run stage, starts at the initial time of the time reference and continues until the end time of the time reference. `run` function is used to run the models, 

```@docs 
run(model::Model)
```

#### Termination
After the run stage, the tasks opened in the initialization stage are closed and the simulation is terminated. `terminate` function is used to terminate the model 

```@docs
terminate(model::Model)
```

`Model`s are constructed to [`simulate`](@ref) them. During the simulation, components of the `Model` process data and the data is transferred between the components via connection. Thus, to simulate the `Model`s, the components **must be connected**. Hence, we connect the components. 
```@repl model_construction_ex 
connect(gen.output, writer.input)
```
In our model, the `writer` is used to record the output of `gen`. Thus, the flows from `gen` to `writer`. Thus, we connect `gen` output to `writer` input. 

!!! note 
    During the `Model` construction, **the order of components are not important**. The components cane be given in any order. For instance, in the example above, the `Model` can be constructed as `model = Model(writer, gen)`.

## Full API 
```@docs 
addcomponent
release(model::Model)
findin
simulate
```
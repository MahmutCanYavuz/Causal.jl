# [Simulation](@id section)

A model to be simulated consists of components connected to each other and a time reference. The time reference is used to sample the continuous-time signals flowing through the connections of the model and to trigger the components. The simulation is performed by triggering the components with pulses generated by the time reference at simulation sampling time intervals. Having been triggered, the components evolve themselves, compute their outputs, and writes them to their output ports.

```@raw html
<center>
    <img src="../../assets/FlowChart/flowchart.svg" alt="model" width="75%"/>
</center>
```

Simulation stages are shown in the flowchart in the figure above. In the first stage, the model is inspected in terms of whether it has algebraic loops. In case they exist, all the algebraic loops are tried to be broken. If an algebraic loop cannot be broken during this stage, an info message informing the user to use unit delay components is printed and simulation is aborted at this stage.

If the inspection stage results positive, the initialization stage comes next. In this stage, the tasks required for the connections of the model to be both readable and writable are activated and bound to the connections. To this end, a putter and a taker task are activated and bound to both sides of each connection. For example, in the figure below is shown a part of a model consisting of the components B1, B2, B3, B4 and connections L1, L2, L3. When triggered, B1(B2) reads data from L1(L2) and writes data to L2(L3). The tasks that are bound on L1 and L2 are shown symbolically the figure. A taker and a putter task are bound to L1 and L2, respectively, corresponding to B1. Similarly, a taker and a putter task are bound to L2 and L3, respectively, corresponding to B2. As a putter task and a taker task is bound to L2, data-flow from B1 to B2 is possible through it.

```@raw html
<head>
    <style>
    * {
    box-sizing: border-box;
    }

    .column {
    float: left;
    width: 50%;
    padding: 5px;
    }

    /* Clearfix (clear floats) */
    .row::after {
    content: "";
    clear: both;
    display: table;
    }

    /* Responsive layout - makes the three columns stack on top of each other instead of next to each other */
    @media screen and (max-width: 500px) {
    .column {
        width: 100%;
    }
    }
    </style>
</head>

<body>
    <div class="row">
        <div class="column">
            <img src="../../assets/TaskForComponents/components.svg" alt="components" style="width:80%">
        </div>
        <div class="column">
            <img src="../../assets/TaskForComponents/tasks.svg" alt="tasks" style="width:100%">
        </div>
    </div>
</body>
```

The run stage follows the initialization stage. The tasks activated in the initialization stage wait for the components to be triggered by the model time reference. During the run stage, a task manager is constructed to trigger the components by writing pulses that are generated in the intervals of the sampling period of the simulation to their trigger pins. The job defined in a task is to read input data from its input port, to calculate its next state—if any—and output, and to write its output to its output port. The run stage starts at the initial time of the time reference and continues until the end time of the time reference.

After the run stage, the tasks opened in the initialization stage are closed and the simulation is terminated.

In some simulation environments, a unified mathematical equation representing the model as a whole is obtained and solved in just a single shot for the entire simulation duration, even if the model is thought to consist of components]. In Jusdl, a model is, again, thought to consist of components, but is not represented by a unified mathematical equation. Instead, the model is evolved by evolving the components individually by solving their own mathematical equations. The components do not evolve in one shot, but instead, they evolve in parallel during the time intervals between subsequent sampling instants. Here, it worths noting that the type of the mathematical equations of the components of a model does not have to be the same. Thus, Jusdl allows the simulation of the models consisting of components represented by different types of mathematical equations.

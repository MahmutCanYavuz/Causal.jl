# Simulation 

A model to be simulated consists of components connected to each other and a time reference. The time reference is used to sample the continuous-time signals flowing through the busses of the model and to trigger the components. The simulation is performed by triggering the components with pulses generated by the time reference at simulation sampling time intervals. Having been triggered, the components evolve themselves, compute their outputs and writes them to their output busses.

```@raw html
<center>
    <img src="../../assets/FlowChart/flowchart.png" alt="model" width="75%"/>
</center>
```

Simulation stages are shown in the flowchart in the figure above. In the first stage, the model is inspected in terms of whether it has unterminated bussed, etc. In case an unterminated bus is inspected, then the simulation is terminated directly. It is also possible to enlarge the scope of the inspection stage to determine whether the model includes algebraic loops, etc.

If the inspection stage results positive, the initialization stage comes next. In this stage, the tasks required for the busses of the model to be both readable and writable are activated and bound to the busses. To this end, a putter and a taker task are activated and bound to both sides of each bus. For example, in the figure below is shown a part of a model consisting of the components B1, B2, B3, B4 and busses L1, L2, L3. When triggered, B1(B2) reads data from L1(L2) and writes data to L2(L3). The tasks that are bound on L1 and L2 are shown symbolically in Figure 2.5b. A taker and a putter task are bound to L1 and L2, respectively, corresponding to B1. Similarly, a taker and a putter task are bound to L2 and L3, respectively, corresponding to B2. As a putter task and a taker task is bound to L2, data-flow from B1 to B2 is possible through it.

```@raw html
<head>
    <style>
    * {
    box-sizing: border-box;
    }

    .column {
    float: left;
    width: 50%;
    padding: 5px;
    }

    /* Clearfix (clear floats) */
    .row::after {
    content: "";
    clear: both;
    display: table;
    }

    /* Responsive layout - makes the three columns stack on top of each other instead of next to each other */
    @media screen and (max-width: 500px) {
    .column {
        width: 100%;
    }
    }
    </style>
</head>

<body>
    <div class="row">
        <div class="column">
            <img src="../../assets/TaskForComponents/components.png" alt="components" style="width:80%">
        </div>
        <div class="column">
            <img src="../../assets/TaskForComponents/tasks.png" alt="tasks" style="width:100%">
        </div>
    </div>
</body>
```

The run stage follows the initialization stage. The tasks activated in the initialization stage wait for the components to be triggered by the model time reference. During the run stage, time reference triggers the components by writing pulses that are generated in the intervals of the sampling period of the simulation to their trigger links. The job defined in a task is to read input data from its input bus, to calculate its next state—if any—and output, and to write its output to its output bus. The run stage starts at the initial time of the time reference and continues until the end time of the time reference.

After the run stage, the tasks opened in the initialization stage are closed and the simulation is terminated.

In some simulation environments, a unified mathematical equation representing the model as a whole is obtained and solved in just a single shot for the entire simulation duration, even if the model is thought to consist of components]. In Jusdl, a model is, again, thought to consist of components, but is not represented by a unified mathematical equation. Instead, the model is evolved by evolving the components individually by solving their own mathematical equations. The components do not evolve in one shot, but instead, they evolve in parallel for during the time intervals between subsequent sampling instants. Here, it worths noting that the type of the mathematical equations of the components of a model does not have to be the same. Thus, Jusdl allows the simulation of the models consisting of components represented by different types of mathematical equations.
